##引用计数
引用计数算法是最初级的垃圾收集算法（IE6,7中用的就是这种算法）
// 定义一个对象{ name: '晓枫', age: 25 }，现在userInfo这个变量引用了它，引用计数为1
const userInfo = {
  name: '晓枫',
  age: 25,
}

const user1 = userInfo // 引用计数2
const user2 = userInfo // 引用计数3

// 现在对象{ name: '晓枫', age: 25 }的引用计数为3，按照引用计数的原理。
// 如果你想让垃圾回收清除它，就需要按照如下操作进行
userInfo = {} // userInfo指向另外一个对象了，所以引用计数为 3 - 1 = 2

user1 = {} // 现在user1对它的引用也没了，引用计数2 - 1 = 1
user2 = {} // 1 - 1 = 0

// 现在{ name: '晓枫', age: 25 }这个对象的引用计数就为0了，垃圾回收就开始工作，把它清理掉了


总结：引用计数优缺点如下：

1、优点：可以即时回收垃圾对象
2、缺点：无法回收循环引用的对象
3、缺点：消耗大，因为要一直维护那个引用计数器

##标记-清除
1、标记：从根对象开始遍历所有对象，能从根对象可达的对象标记为活动对象。
2、清除：从根对象开始遍历所有对象，没有标记为活动对象的一律清除。
onst a = { num: 10 }

function fn1() {
  const b = { num: 20 }
  return b
}
const c = fn1()

function fn2() {
  const d = { num: 30 }
  return 'ccc'
}
const e = fn2()


// 答案：{ num: 10 }{ num: 20 }全局可达， { num: 30 }在函数执行完成后就不可达了，垃圾回收的时候就会清理掉

总结：标记清除优缺点：

1、优点：可以回收循环引用的对象
2、缺点：容易产生碎片化空间，造成浪费
3、确定：无法立即清除无用对象，垃圾攒到一定程度在开始回收

V8 垃圾回收
V8垃圾回收总体是分为新生代和老生带两种：

新生代：一些存活时间短，容易发生变化的对象，比如函数内部定义的变量，如果不考虑闭包的情况，函数执行完，这些对象就应该被当做垃圾回收。内存限制64位系统32MB
老生带：一些存活时间长，常驻内存的对象，比如一些全局变量啊等等。内存限制64位1.4GB。

新生代因为存放的是一些存活时间短的对象，所以为了效率考虑，其回收频率也会比较高。其回收策略采用的是标记 + 复制。
新生代内存等分为两个区域，From为活动区域，To为复制区域。当要触发垃圾回收的时候，From就会先进行标记，标记完成后，将可达对象（活动对象）复制到To区域，然后把From区域整理进行清除，清除完成后From和To区域交换一下
我们前面说过新生代内存上限是32MB，这点内存很容易就能达到，所以如果一些对象经常存在新生代里的话，很容易新生代内存就占满了，所以V8存在一种晋升机制，但满足下面条件的时候，新生代对象就会移动到老生代区域，简称晋升。

1、这个过程发生在From区域将活动对象拷贝至To区域过程中。
2、一轮垃圾回收（GC）后还存活的新生带对象需要晋升。也就是说上一轮垃圾回收后，这一轮垃圾回收发现你还是活动对象，就需要把你晋升到老生代区域。
3、To空间的使用率超过25%，如果超过25%，后续对象直接晋升。这也是个衡量结果，超过25%，后续新进来的对象就会有些不够用了。

V8如何回收老生代
老生代存一些持续时间久的对象，比如全局变量，闭包等。它可分配内存大，而且回收频率不像老生代那么频繁。所以它的垃圾回收机制也和不太一样。
老生代主要是用标记清除策略进行垃圾回收，但是前面说过，标记清除会产生碎片化内存，当新生代对象要晋升到老生代，而老生代没有空间可存的时候，老生代就会进行一次标记整理进行空间优化，优化后在进行晋升操作。

老生代还有一种优化方式叫做增量标记，前面说过垃圾回收（分标记和回收两个阶段）会阻塞JS执行，如果你都攒到一起回收的话，时间会较长，所以V8就采用了增量标记策略，说人话就是，程序执行和垃圾回收穿插着来，这样用户的感知就不明显了

新生代因为内存小，最大32MB（无法忍受碎片空间）并且需要频繁触发，所以分了两份空间，清理的时候直接将活动对象copy到另一份空间中，然后把这个空间整体释放，这样好处就是快，采用了空间换时间的概念。
老生代内存大，最大1.4GB，触发相对新生代没那么频繁，内存相对充裕，所以不用每次都整理，就采用相对快的标记清除算法，当内存不足了，在去整体整理一下就行。采用时间换空间的概念，你想想如何老生代也分一半出来的话，那么700MB内存每次都空着，这样利用率就太低了。

1、V8是目前一款主流的JavaScript执行引擎，你所熟知的Chrome、Edge、Electron等都是用的V8引擎。
2、V8是设置内存上限的，64位上限1.4GB、32位设置700MB。
3、V8内存分为新生代和老生代。并且采用分代回收的策略进行垃圾回收。
4、新生代采用标记 + 复制策略，老生代采用标记清除（主） + 标记整理（辅）+ 增量标记策略。
